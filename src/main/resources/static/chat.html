<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat App</title>
  <link rel="stylesheet" href="/css/styles.css">
</head>
<body>
<div id="userListContainer">
  <h3>Conversations</h3>
  <button id="createChatButton">Create New Chat</button>
  <ul id="userList"></ul>
</div>

<div id="chatContainer" style="display:none;">
  <div id="chatTitle"></div>
  <div id="chatArea"></div>
  <div class="input-container">
    <input type="text" id="messageInput" placeholder="Type a message..."/>
    <button id="sendButton">Send</button>
  </div>
</div>

<div id="createChatModal" class="modal">
  <div class="modal-content">
    <h3>Create New Conversation</h3>
    <div class="user-select-list" id="userSelectList"></div>
    <div class="modal-buttons">
      <button class="modal-button secondary" onclick="closeModal()">Cancel</button>
      <button class="modal-button primary" onclick="createNewConversation()">Create</button>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.0/sockjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
<script>
  let stompClient = null;
  let currentConversationId = null;
  let currentUserId = null;
  let username = null;

  // Connect to WebSocket
  function connectWebSocket() {
    const socket = new SockJS('/ws'); // Ensure your WebSocket endpoint matches the backend configuration
    stompClient = Stomp.over(socket);

    stompClient.connect({}, () => {
      console.log('Connected to WebSocket');
    }, (error) => {
      console.error('WebSocket connection error:', error);
    });
  }

  // Fetch logged-in user details
  async function fetchCurrentUser() {
    try {
      const response = await fetch('/api/current-username');
      username = await response.text();

      const userResponse = await fetch(`/api/users`);
      const users = await userResponse.json();
      const currentUser = users.find(user => user.username === username);

      if (currentUser) {
        currentUserId = currentUser.id;
      }
      return currentUser;
    } catch (error) {
      console.error('Error fetching current user:', error);
      return null;
    }
  }

  // Fetch users excluding the logged-in user
  async function fetchUsers() {
    try {
      const usersResponse = await fetch('/api/users');
      const users = await usersResponse.json();
      const userListElement = document.getElementById('userList');
      userListElement.innerHTML = '';

      users.forEach(user => {
        if (user.username !== username) {
          const userItem = document.createElement('li');
          userItem.textContent = user.username;
          userItem.onclick = () => startConversation(user.username);
          userListElement.appendChild(userItem);
        }
      });
    } catch (error) {
      console.error('Error fetching users:', error);
    }
  }

  // Start conversation with a selected user
  async function startConversation(selectedUsername) {
    try {
        // Clear previous chat messages
        document.getElementById("chatTitle").textContent = `Chat with ${selectedUsername}`; // Set the title
        document.getElementById("chatArea").innerHTML = '';

        const response = await fetch(`/api/conversations?user1=${username}&user2=${selectedUsername}`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const conversation = await response.json();
        currentConversationId = conversation.id;

        document.getElementById("chatContainer").style.display = "block";

        // First fetch existing messages, then subscribe to new ones
        if (currentConversationId) {
            await fetchMessages(currentConversationId);
            subscribeToConversation(currentConversationId);
        }
    } catch (error) {
        console.error('Error starting conversation:', error);
    }
}

// Also add cleanup on window unload
window.addEventListener('beforeunload', () => {
    if (currentSubscription) {
        currentSubscription.unsubscribe();
    }
    if (stompClient) {
        stompClient.disconnect();
    }
});
   let currentSubscription = null;
  // Subscribe to a specific conversation topic
  function subscribeToConversation(conversationId) {
   if (currentSubscription) {
        currentSubscription.unsubscribe();
        currentSubscription = null;
    }

    if (stompClient) {
        currentSubscription = stompClient.subscribe(`/topic/conversation/${conversationId}`, (message) => {
            const receivedMessage = JSON.parse(message.body);
            appendMessage(receivedMessage);
        });
    }
}

  // Fetch messages for the current conversation
  async function fetchMessages(conversationId) {
    try {
      const response = await fetch(`/api/conversations/${conversationId}/messages`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const messages = await response.json();
      displayMessages(messages);
    } catch (error) {
      console.error('Error fetching messages:', error);
    }
  }

 function displayMessages(messages) {
    const chatArea = document.getElementById("chatArea");
    chatArea.innerHTML = ''; // Curăță zona de chat înainte de a afișa mesajele noi

    if (messages && messages.length > 0) { // Verificare suplimentară
        messages.forEach(message => appendMessage(message));
    } else {
        // Opțional: Afișează un mesaj dacă nu există mesaje
        const noMessagesDiv = document.createElement('div');
        noMessagesDiv.textContent = "Nu există mesaje în această conversație.";
        chatArea.appendChild(noMessagesDiv);
    }

}

// Append a single message to the chat area
function appendMessage(message) {
    const chatArea = document.getElementById("chatArea");
    const messageDiv = document.createElement('div');

    if (!message || !message.sender || !message.sender.id) {
        console.error("Mesaj invalid:", message); // Logare pentru debug
        return; // Ieșire din funcție dacă mesajul este invalid
    }

    const isCurrentUser = message.sender.id === currentUserId;
    messageDiv.className = isCurrentUser ? 'message current-user' : 'message other-user';

    const senderName = isCurrentUser ? "You" : message.sender.username || "Unknown";
    const formattedTimestamp = formatTimestamp(message.timestamp);

    messageDiv.innerHTML = `
        <div class="message-content">
            ${!isCurrentUser ? `<strong class="sender-name">${senderName}</strong>` : ""}
            <p>${message.content}</p>
            <span class="timestamp">${formattedTimestamp}</span>
        </div>
    `;

    chatArea.appendChild(messageDiv);
    chatArea.scrollTop = chatArea.scrollHeight;
}

function formatTimestamp(timestamp) {
    if (!timestamp) return "Unknown time";
    const date = new Date(timestamp);
    return date.toLocaleTimeString() + " " + date.toLocaleDateString();
}


  // Send a new message via WebSocket
  function sendMessage() {
    const messageInput = document.getElementById("messageInput");
    const messageContent = messageInput.value.trim();

    if (messageContent && currentConversationId && stompClient) {
        const message = {
            content: messageContent,
            senderId: currentUserId,
            sender: {
                id: currentUserId,
                username: username
            },
            conversationId: currentConversationId,
            timestamp: new Date().toISOString()
        };

        // Send via WebSocket for real-time update
        stompClient.send(`/app/conversation/${currentConversationId}/send-message`, {}, JSON.stringify(message));
        messageInput.value = '';

        // Also save to database via HTTP POST
        fetch(`/api/conversations/${currentConversationId}/messages`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(message)
        }).catch(error => console.error('Error saving message:', error));

        messageInput.value = '';
    }
}
 function setupEventListeners() {
            document.getElementById('createChatButton').addEventListener('click', showCreateChatModal);
            document.getElementById('messageInput').addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    sendMessage();
                }
            });
            document.getElementById('sendButton').addEventListener('click', sendMessage);
        }
         async function fetchConversations() {
            try {
                const response = await fetch(`/api/users/${currentUserId}/conversations`);
                const conversations = await response.json();
                displayConversations(conversations);
            } catch (error) {
                console.error('Error fetching conversations:', error);
            }
        }
        async function selectConversation(conversation) {
    try {
        // Clear previous chat messages
        document.getElementById("chatArea").innerHTML = '';

        // Update current conversation ID
        currentConversationId = conversation.id;

        const otherParticipants = conversation.users
        .filter(user => user.id !== currentUserId)
        .map(user => user.username)
        .join(', ');
    document.getElementById("chatTitle").textContent = `Chat with ${otherParticipants}`; // Set the title

        // Show chat container
        document.getElementById("chatContainer").style.display = "block";

        // Update active conversation in sidebar
        const conversationItems = document.querySelectorAll('.conversation-item');
        conversationItems.forEach(item => item.classList.remove('active'));
        event.currentTarget.classList.add('active');

        // First fetch existing messages, then subscribe to new ones
        if (currentConversationId) {
            await fetchMessages(currentConversationId);
            subscribeToConversation(currentConversationId);
        }
    } catch (error) {
        console.error('Error selecting conversation:', error);
    }
}

         function displayConversations(conversations) {
            const userList = document.getElementById('userList');
            userList.innerHTML = '';

            conversations.forEach(conversation => {
                const li = document.createElement('li');
                li.className = 'conversation-item';
                li.onclick = () => selectConversation(conversation);

                // Get other participants' names for display
                const otherParticipants = conversation.users
                    .filter(user => user.id !== currentUserId)
                    .map(user => user.username)
                    .join(', ');

                li.textContent = conversation.name || otherParticipants;
                userList.appendChild(li);
            });
        }
          async function showCreateChatModal() {
            const modal = document.getElementById('createChatModal');
            const userSelectList = document.getElementById('userSelectList');
            userSelectList.innerHTML = '';

            try {
                const response = await fetch('/api/users');
                const users = await response.json();

                users.forEach(user => {
                    if (user.id !== currentUserId) {
                        const div = document.createElement('div');
                        div.className = 'user-select-item';
                        div.innerHTML = `
                            <input type="checkbox" id="user-${user.id}" value="${user.id}">
                            <label for="user-${user.id}">${user.username}</label>
                        `;
                        userSelectList.appendChild(div);
                    }
                });

                modal.style.display = 'block';
            } catch (error) {
                console.error('Error fetching users:', error);
            }
        }

        // Close create chat modal
        function closeModal() {
            document.getElementById('createChatModal').style.display = 'none';
        }

        // Create new conversation
        async function createNewConversation() {
            const selectedUsers = Array.from(document.querySelectorAll('#userSelectList input[type="checkbox"]:checked'))
                .map(checkbox => parseInt(checkbox.value));

            if (selectedUsers.length === 0) {
                alert('Please select at least one user');
                return;
            }

            try {
                const response = await fetch('/api/conversations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        userIds: [...selectedUsers, currentUserId]
                    })
                });

                if (response.ok) {
                    const conversation = await response.json();
                    closeModal();
                    await fetchConversations();
                    selectConversation(conversation);
                }
            } catch (error) {
                console.error('Error creating conversation:', error);
            }
        }

  // Initialize the app
   async function initApp() {
            try {
                connectWebSocket();
                const currentUser = await fetchCurrentUser();
                if (currentUser) {
                    await fetchConversations();
                    setupEventListeners();
                }
            } catch (error) {
                console.error('Error initializing app:', error);
            }
        }

  // Add event listener for Enter key in message input
  document.getElementById("messageInput").addEventListener("keypress", function(event) {
    if (event.key === "Enter") {
      sendMessage();
    }
  });

  window.onload = initApp;
</script>
</body>
</html>